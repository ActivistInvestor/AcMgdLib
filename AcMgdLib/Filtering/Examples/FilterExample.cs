/// FilterExample.cs  
/// 
/// ActivistInvestor / Tony T.
/// 
/// Distributed under the terms of the MIT license.

using Autodesk.AutoCAD.Runtime;

namespace System.Linq.Expressions.Predicates.Examples
{
   /// <summary>
   /// The Filter<T> class is abstract. So, testing
   /// it requires a concrete type derived from it.
   /// This is a minimal concrete implementation of 
   /// Filter<T>, mainly for demonstration purposes.
   /// </summary>

   public class ExampleFilter<T> : Filter<T>
   {
      Expression<Func<T, bool>> predicate;

      public ExampleFilter(Expression<Func<T, bool>> predicate)
      {
         this.predicate = predicate;
      }

      protected override Expression<Func<T, bool>> GetBaseExpression()
      {
         return predicate;
      }
   }

   /// <summary>
   /// Example showing Filter<T> composability:
   /// </summary>

   public static class FilterExample
   {
      [CommandMethod("FILTEREXAMPLE")]
      public static void Run()
      {
         /// Define a filter for integers that excludes
         /// values greater than 9:
         
         var filter1 = new ExampleFilter<int>(x => x < 10);

         /// Display filter1's expression:
         AcConsole.WriteLine($"filter1: {filter1.Expression.ToString()}");

         /// Define a filter for integers that excludes
         /// values less than 6:
         
         var filter2 = new ExampleFilter<int>(y => y > 5);

         /// Display filter2's expression:
         AcConsole.WriteLine($"filter2: {filter2.Expression.ToString()}");

         /// Logically-combine the two filters, adding
         /// the criteria defined by filter2 to filter1,
         /// in a logical 'and' operation:

         filter1.Add(filter2);

         /// Display filter1's expression again:
         AcConsole.WriteLine($"filter1: {filter1.Expression.ToString()}");

         /// The above call to Add() modifies filter1,
         /// but leaves filter2 as it was.
         /// 
         /// After the call to Add(), the delegate 
         /// generated by filter1 becomes:
         /// 
         ///   arg => arg < 10 && arg > 5
         ///
         /// In fact, the argument passed to Add() need not
         /// be another instance of a Filter<T>. It can be
         /// any valid expression that's compatible with the 
         /// filter's expression.
         ///
         /// For example, one can reach the same result
         /// the above call to Add() yields, with this:
         ///
         ///   filter1.Add(y => y > 5);
         ///
         /// The purpose served by combining filters rather
         /// than just expressions is to support specialized
         /// filters that can have state and can use that to 
         /// state to determine the result of their predicates.
         /// 
         /// Concrete examples of this type of composability
         /// can be seen in various types in this library, such
         /// as the OwnerFilter class, which filters entities 
         /// by the block(s) that contain them.
      }
   }

}



